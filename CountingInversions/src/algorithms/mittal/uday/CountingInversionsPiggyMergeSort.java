package algorithms.mittal.uday;

import java.io.File;
import java.io.FileNotFoundException;
import java.util.ArrayList;
import java.util.Scanner;

public class CountingInversionsPiggyMergeSort {

	/**
	 * Class to hold counted inversions and the 
	 * resulting sorted array generated by merge step
	 * @author uday
	 *
	 */
	public static class Tuple{
		long inversions;
		int sortedArray[];
		public Tuple()
		{
			
		}
		public Tuple(long inversions, int array[]){
			this.inversions=inversions;
			this.sortedArray=array;
		}
		public long getInversions() {
			return inversions;
		}
		public void setInversions(long inversions) {
			this.inversions = inversions;
		}
		public int[] getSortedArray() {
			return sortedArray;
		}
		public void setSortedArray(int[] sortedArray) {
			this.sortedArray = sortedArray;
		}
		
	}
	
	public static void main(String[] args) {
		Scanner scanner = null;
		try {
			scanner = new Scanner(new File("/Users/uday/Desktop/IntegerArray.txt"));
		} catch (FileNotFoundException e) {
			System.out.println("File not Found?");
		}
		int [] tall = new int[100000];
		int i = 0;
		while(scanner.hasNextInt()){
		   tall[i++] = scanner.nextInt();
		}
		Tuple inversionResult = new Tuple();
		inversionResult.setInversions(0);
		inversionResult.setSortedArray(tall);
		inversionResult = sortAndCountInversions(inversionResult);
		System.out.println("Number of inversions found are: " + String.valueOf(inversionResult.getInversions()));
	}
	
	private static Tuple sortAndCountInversions(Tuple inversionResult){
		int inputSize = inversionResult.getSortedArray().length;
		if(inputSize <=1){
			return inversionResult;
		}
		int leftArray[], rightArray[];
		if(inputSize % 2==0){
			leftArray = new int[inputSize/2];
			System.arraycopy(inversionResult.getSortedArray(), 0, leftArray, 0, inputSize/2);
			rightArray = new int[inputSize/2];
			System.arraycopy(inversionResult.getSortedArray(), inputSize/2, rightArray, 0, inputSize/2);
			
		}
		else{
			leftArray = new int[(int) Math.floor(inputSize/2)];
			System.arraycopy(inversionResult.getSortedArray(), 0, leftArray, 0, (int) Math.floor(inputSize/2));
			rightArray = new int[inputSize - leftArray.length];
			System.arraycopy(inversionResult.getSortedArray(), (int) Math.floor(inputSize/2), rightArray, 0, inputSize - leftArray.length);
		}
		
		Tuple leftInversionsTuple = new Tuple(0,leftArray);
		Tuple rightInversionsTuple = new Tuple(0,rightArray);
		leftInversionsTuple = sortAndCountInversions(leftInversionsTuple);
		rightInversionsTuple = sortAndCountInversions(rightInversionsTuple);
		Tuple splitInversionsTuple = sortAndCountSplitInversions(leftInversionsTuple, rightInversionsTuple, inputSize);
		return new Tuple(leftInversionsTuple.getInversions() 
				+ rightInversionsTuple.getInversions()
				+ splitInversionsTuple.getInversions(), splitInversionsTuple.getSortedArray());
	}

	private static Tuple sortAndCountSplitInversions(Tuple leftInversionsTuple, Tuple rightInversionsTuple, int inputSize) {
		//TODO sort the arrays while counting the inversions
		if(inputSize == 1){
			//BaseCase
			return new Tuple(0, leftInversionsTuple.getSortedArray().length > 0 ? leftInversionsTuple.getSortedArray() : rightInversionsTuple.getSortedArray());
		}
		Tuple result = new Tuple();
		long numInversions = 0;
		int i=0, k=0;
		int sortedArray[] = new int[inputSize];
		int leftArray[] = leftInversionsTuple.getSortedArray();
		int rightArray[] = rightInversionsTuple.getSortedArray();
		for(int j=0; j<inputSize; j++){
			if(i<leftArray.length && k<rightArray.length){
				if(leftArray[i]<=rightArray[k]){
					sortedArray[j]=leftArray[i];
					i++;
					continue;
				}
				if(leftArray[i]>=rightArray[k]){
					sortedArray[j]=rightArray[k];
					k++;
					numInversions += leftArray.length - i;
					continue;
				}
			}
			else{
				if(i<leftArray.length){
					sortedArray[j]=leftArray[i];
					i++;
					continue;
				}
				if(k<rightArray.length){
					sortedArray[j]=rightArray[k];
					k++;
					continue;
				}
			}
			
			
		}
		result.setInversions(numInversions);
		result.setSortedArray(sortedArray);
		return result;
	}

}
